---
title: 存放元素的容器
tags: 集合
categories: Java
---

在编程中，常常需要集中存放多个数据。从传统意义上讲，数组是我们的一个很好的选择，前提是我们事先已经明确知道我们将要保存的对象的数量。一旦在数组初始化时指定了这个数组长度，这个数组长度就是不可变的，如果我们需要保存一个可以动态增长的数据(在编译时无法确定具体的数量)，java的集合类就是一个很好的设计方案了。
集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。所以的集合类都位于java.util包下，后来为了处理多线程环境下的并发安全问题，java5还在java.util.concurrent包下提供了一些多线程支持的集合类。
Java容器类类库的用途是"保存对象"，并将其划分为两个不同的概念：
* Collection
一组"对立"的元素，通常这些元素都服从某种规则
    * List必须保持元素特定的顺序
    * Set不能有重复元素
    * Queue保持一个队列(先进先出)的顺序
* Map
一组成对的"键值对"对象
<!-- more -->

# 集合与数组
* 数组：大小固定，只能存储相同数据类型的数据
* 集合：大小可动态扩展，可以存储各种类型的数据

# Collection
单列集合,存储的元素是单独出现的
## List
有序（输出的顺序就是插入的顺序）并且允许重复，元素可以为null
* ArrayList
基于动态数组实现，查询快，增删慢
* LinkedList
基于双向链表实现，查询慢，增删快
* Vector
同ArrayList，但是线程安全的（使用Synchronized关键字），性能略低于ArrayList
    * Stack
    继承Vector,用于模拟“栈”，后进先出

## Set
无序（输出的顺序不一定是插入的顺序）并且不允许重复，元素有且只有一个可以为null
* HashSet
基于HashMap的key实现，value为同一个值，无序，具有良好的存取和查找性能。当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到一个值，然后根据该值决定该对象在HashSet中的存储位置。
HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法的返回值相等。
    * LinkedHashSet
    基于LinkedHashMap实现，使用链表维护元素的次序，性能略低于HashSet
* SortedSet（接口）
    * TreeSet
    基于TreeMap实现，可以确保集合元素处于排序状态，支持两种排序方式：自然排序或定制排序

## Queue
用于模拟“队列”，先进先出

# Map
双列集合，存储的元素是成对出现的，用于存储键值对，根据键得到值。
* HashMap
基于哈希表实现。工作原理：简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。
所以，性能考虑，HashMap中的链表出现越少，性能才会越好。当链表长度为8的时候链表转换为红黑树（jdk1.8新增）查找的方式来优化性能。
HashMap在并发环境下，可能会形成环状链表。Hash DOS攻击。可以使用Collections.synchronizedMap()方法实现hashMap线程安全。
    * LinkedHashMap
    使用链表维护元素的次序，性能略低于HashMap
* HashTable
同HashMap,但是线程安全的，且键和值都不允许为null,性能略低于HashMap
* ConcurrentHashMap
同HashMap，作为一种线程安全且高效的哈希表的解决方案，尤其是其中的"分段锁"的方案，相比HashTable的全表锁在性能上的提升非常之大。
* SortedMap（接口）
    * TreeMap
    基于红黑树实现，可以确保集合元素处于排序状态，支持两种排序方式：自然排序或定制排序

# 集合的扩容机制
1. HashMap（HashSet同HashMap） 、HashTable
* HashMap
初始容量：16
扩容因子：0.75，即当 元素个数 超过 容量长度的0.75倍 并且发生Hash冲突时，进行扩容
扩容后长度：原长度 * 2
* HashTable
初始容量：11
扩容因子：同HashMap
扩容后长度：原长度 * 2 + 1
2. ArrayList、Vector
* ArrayList
初始容量：10
扩容时机：即当 元素个数 超过 容量长度 时，进行扩容
扩容后长度：原长度 * 1.5 + 1
* Vector
初始容量：10
扩容时机：即当 元素个数 超过 容量长度 时，进行扩容
扩容后长度：原长度 * 2
