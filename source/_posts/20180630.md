---
title: 集合
tags: 集合
categories: Java
---

在编程中，常常需要集中存放多个数据。从传统意义上讲，数组是我们的一个很好的选择，前提是我们事先已经明确知道我们将要保存的对象的数量。一旦在数组初始化时指定了这个数组长度，这个数组长度就是不可变的，如果我们需要保存一个可以动态增长的数据(在编译时无法确定具体的数量)，java的集合类就是一个很好的设计方案了。
集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。所以的集合类都位于java.util包下，后来为了处理多线程环境下的并发安全问题，java5还在java.util.concurrent包下提供了一些多线程支持的集合类。
Java容器类类库的用途是"保存对象"，并将其划分为两个不同的概念：
* Collection
一组"对立"的元素，通常这些元素都服从某种规则
    * List必须保持元素特定的顺序
    * Set不能有重复元素
    * Queue保持一个队列(先进先出)的顺序
* Map
一组成对的"键值对"对象
<!-- more -->

# 集合与数组的区别
* 数组：大小固定，只能存储相同数据类型的数据
* 集合：大小可动态扩展，可以存储各种类型的数据

# 数据结构
数据结构的物理存储结构只有两种：顺序存储结构和链式存储结构（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式）
* 数组
采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(log n)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)
* 链表
对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)
* 树
    * 二叉树：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(log n)。
    * 红黑树
* 哈希表
不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，增删改查的性能十分之高。 哈希表的主干是数组，比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作，即存储位置 = f(关键字)，其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。
    * 哈希冲突：两个不同的元素，通过哈希函数得出的实际存储地址相同
    解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），链地址法（数组 + 链表），再散列函数法。
    
# Collection
单列集合,存储的元素是单独出现的
## List
有序（输出的顺序就是插入的顺序）并且允许重复，元素可以为null
* ArrayList
基于动态数组实现，查询快，增删慢
* LinkedList
基于双向链表实现，查询慢，增删快
* Vector
同ArrayList，但是线程安全的（使用Synchronized关键字），性能略低于ArrayList
    * Stack
    继承Vector,用于模拟“栈”，后进先出
## Set
无序（输出的顺序不一定是插入的顺序）并且不允许重复，元素有且只有一个可以为null
* HashSet
基于HashMap的key实现，value为同一个值，无序，具有良好的存取和查找性能。当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到一个值，然后根据该值决定该对象在HashSet中的存储位置。HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法的返回值相等。
    * LinkedHashSet
    基于LinkedHashMap实现，使用链表维护元素的次序，性能略低于HashSet
* SortedSet（接口）
    * TreeSet
    基于TreeMap实现，可以确保集合元素处于排序状态，支持两种排序方式：自然排序或定制排序
* EnumSet（不常用）
EnumSet中所有元素都必须是指定枚举类型的枚举值
## Queue
用于模拟“队列”，先进先出
* PriorityQueue
* Deque

# Map
双列集合，存储的元素是成对出现的
用于存储键值对，根据键得到值，因此键不允许键重复,但允许值重复
* HashMap（重点掌握工作原理及代码实现）
基于哈希表实现。工作原理：简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。当链表长度为8的时候链表转换为红黑树（jdk1.8新增，之前为二叉树）查找的方式来优化性能。HashMap在并发环境下，可能会形成环状链表。Hash DOS攻击。
    * LinkedHashMap
    使用链表维护元素的次序，性能略低于HashMap
* HashTable
同HashMap,但是线程安全的，且键和值都不允许为null,性能略低于HashMap
    * Properties 
    用于模拟“属性文件”
* ConcurrentHashMap
同HashMap，作为一种线程安全且高效的哈希表的解决方案，尤其是其中的"分段锁"的方案，相比HashTable的全表锁在性能上的提升非常之大。
* SortedMap（接口）
    * TreeMap
    基于红黑树实现，可以确保集合元素处于排序状态，支持两种排序方式：自然排序或定制排序
* WeakHashMap
与HashMap基本相似，但HashMap的key保留了对实际对象的"强引用",而WeakHashMap的key只保留了对实际对象的“弱引用”，影响垃圾回收
* IdentityHashMap
与HashMap基本相似，但当且仅当两个key严格相等(key1 == key2)时，IdentityHashMap才认为两个key相等
* EnumMap
EnumMap是一个与枚举类一起使用的Map实现，EnumMap中的所有key都必须是单个枚举类的枚举值。创建EnumMap时必须显式或隐式指定它对应的枚举类。EnumMap根据key的自然顺序(即枚举值在枚举类中的定义顺序)

# 集合扩容机制
1. HashMap（HashSet同HashMap） 、HashTable
* HashMap
初始容量：16
扩容因子：0.75，即当 元素个数 超过 容量长度的0.75倍 并且发生Hash冲突时，进行扩容
扩容后长度：原长度 * 2
* HashTable
初始容量：11
扩容因子：同HashMap
扩容后长度：原长度 * 2 + 1
2. ArrayList、Vector
* ArrayList
初始容量：10
扩容时机：即当 元素个数 超过 容量长度 时，进行扩容
扩容后长度：原长度 * 1.5 + 1
* Vector
初始容量：10
扩容时机：即当 元素个数 超过 容量长度 时，进行扩容
扩容后长度：原长度 * 2
