---
title: 开源框架
tags: [Spring,SpringMVC,Hibernate,MyBatis,Spring Boot]
categories: 后端开发    
---

一般做框架的想法是出于以下几种考虑的
* 目前现有的解决方案已经不能有效解决出现的问题，需要一个全新的框架和技术理论来处理
* 现在的问题大部分都能解决，但是对于特定的问题还没有方便的处理方式，只是需要一个更好或者更方便的解决特定问题的办法
所以要么做通用的框架，这种框架有非常好的扩展性，能够适应不同的应用场景；要么做一个针对特定应用场景的框架，让框架本身能够继承一些特定服务以简化开发。
<!-- more -->

# Spring
## 设计理念
Java是面向对象编程，而Spring是面向Bean编程。
构建一个数据结构，然后根据这个结构设计它的生存环境，并让它在这个环境中按照一定的规律不停的运动，在它们的不停运动中设计一个系列与环境或者与其他个体完成信息交换。、

## 核心组件
### Bean（演员）
Bean的创建是典型的工厂模式，它的顶级接口是BeanFactory。
Bean的定义
Bean的解析
* 作用域
    * singleton（默认作用域）
    单例模式，Spring IoC容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，始终指向同一对象。Singleton作用域是Spring中的缺省作用域
    * prototype
    原型模式，每次通过Spring容器获取prototype定义的bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态，而singleton全局只有一个对象。根据经验，对有状态的bean使用prototype作用域，而对无状态的bean使用singleton作用域
    * request
    在一次Http请求中，容器会返回该Bean的同一实例。而对不同的Http请求则会产生新的Bean，而且该bean仅在当前Http Request内有效
    * session
    在一次Http Session中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效
    * global session
    在一个全局的Http Session中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效
* 生命周期
    1. 实例化一个Bean，也就是我们通常说的new    
    2. 按照Spring上下文对实例化的Bean进行配置，也就是IOC注入    
    3. 如果这个Bean实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的是Spring配置文件中Bean的ID    
    4. 如果这个Bean实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()，传递的是Spring工厂本身（可以用这个方法获取到其他Bean）    
    5. 如果这个Bean实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文，该方式同样可以实现步骤4，但比4更好，以为ApplicationContext是BeanFactory的子接口，有更多的实现方法 
    6. 如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用After方法，也可用于内存或缓存技术   
    7. 如果这个Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法  
    8. 如果这个Bean关联了BeanPostProcessor接口，将会调用postAfterInitialization(Object obj, String s)方法    
    9. 当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean接口，会调用其实现的destroy方法   
    10. 最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法    
### Context（舞台）
BeanFactory和ApplicationContext的区别
ApplicationContext是Context的顶级父类，标识一个应用环境的基本信息，继承了BeanFactory。
### Core（道具）
Resource，定义类资源的访问方式，把所有的资源都抽象成一个接口。
    
## DI（重点掌握）
IOC:控制反转,是一种设计思想，可以用来降低代码之间的耦合度。传统JavaSE程序设计，是程序主动去创建和获取依赖对象，而在Spring中，由IOC容器负责对象的创建及注入。
DI:依赖注入,IOC的一种实现方式，基于反射实现，一般通过构造器或setter方法注入。
用@Service、@Repository等注解标识类为Bean，用@Resource标识自动注入。
工厂模式
实现原理

## AOP（重点掌握）
面向切面编程（AOP）是解决特定问题的一种编程范式，核心目的是为了分离功能性需求和非功能性需求
* 应用场景：事务控制、权限控制、缓存控制、审计日志、异常处理、性能监控、分布式追踪等
* 实现原理：基于动态代理实现。
JDK动态代理只能对实现了接口的类生成代理，而不能针对类，CGLib是针对类实现代理，底层采用ASM字节码生成代理类，主要是对指定的类生成一个子类，覆盖其中的方法（继承）。jdk6之前，CGLib比JDK代理效率高，之后JDK代理效率要高于CGLib。故当Bean实现接口时，Spring就会用JDK的动态代理，当Bean没有实现接口时，Spring使用CGLib是实现，可以强制使用CGLib。
* 好处：集中处理某一关注点/横切逻辑；可以很方便地添加/删除关注点；侵入性少，增强代码可读性及可维护性
* 相关概念：
    1. 切面（aspect）
    切面是一个关注点的模块化，这个关注点可能是横切多个对象，Spring中常使用@Aspect注解一个类使其称为一个切面。
    2. 连接点（join point）
    连接点是指在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候
    3. 通知（advice）
    指在切面的某个特定的连接点上执行的动作
    通知类型：
        * 前置通知
        * 后置通知
        * 返回通知
        * 异常通知
        * 环绕通知
    4. 切点（pointcut）
    指匹配连接点的断言。通知与一个切入点表达式关联，并在满足这个切入的连接点上运行，例如：当执行某个特定的名称的方法
    5. 目标对象（Target Object）
    目标对象是被一个或者多个切面所通知的对象
    6. AOP代理（AOP Proxy）
    AOP代理是指AOP框架创建的对对象，用来实现切面契约（包括通知方法等功能）
    7. 织入（weave）
    指把切面连接到其他应用出程序类型或者对象上，并创建一个被通知的对象。或者说形成代理对象的方法的过程

## 事务
* 实现方式

* 传播机制
    * PROPAGATION_REQUIRED
    表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务
    * PROPAGATION_SUPPORTS
    表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行
    * PROPAGATION_MANDATORY
    表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常
    * PROPAGATION_REQUIRED_NEW
    表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager
    * PROPAGATION_NOT_SUPPORTED
    表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager
    * PROPAGATION_NEVER
    表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常
    * PROPAGATION_NESTED
    表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务
* 隔离级别
    * ISOLATION_DEFAULT：使用数据库默认的隔离级别
    * ISOLATION_READ_UNCOMMITTED：允许读取改变了的还未提交的数据，可能导致脏读、不可重复读和幻读
    * ISOLATION_READ COMMITTED：允许并发事务提交之后读取，可以避免脏读，可能导致重复读和幻读
    * ISOLATION_REPEATABLE_READ：对相同字段的多次读取结果一致，可导致幻读
    * ISOLATION_SERIALIZABLE：完全服从ACID的原则，确保不发生脏读、不可重复读和幻读
* 底层原理
基于AOP实现
* 常见问题
Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑。

## Spring Data JPA

# SpringMVC
## 运行流程
* 用户发送请求至前端控制器DispatcherServlet
* DispatcherServlet收到请求调用HandlerMapping处理器映射器。
* 处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果没有则生成)一并返回给DispatcherServlet。
* DispatcherServlet通过HandlerAdapter处理器适配器调用处理器
* 执行处理器(Controller，也叫后端控制器)执行完成返回ModelAndView。
* HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet
* DispatcherServlet将ModelAndView传给ViewResolver视图解析器
* ViewResolver解析后返回具体View
* DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。
* DispatcherServlet响应用户
## 启动流程
* initMultipartResolver：用于处理文件上传服务
* initLocaleResolver：用于处理应用的国际化问题
* initThemeResolver：用于定义一个主题
* initHandlerMappings：用于定义用户设置的请求映射关系
* initHandlerAdapter：用于根据Handler的类型定义不同的处理规则
* initHandlerExceptionResolver：当Handler处理出错时，会通过这个Handler来统一处理
* initRequestToViewNameTranslator：将指定的ViewName按照定义的requestToViewNameTranslator替换成想要的格式，如加上前缀或者后缀
* initViewResolvers：用于将View解析成页面

# Hibernate

# MyBatis
* 实现原理
MyBatis通过SQL Map将Java对象映射成SQL语句，将结果集再转化成Java对象。

# SpringBoot
* 优点：
    * 去除了大量的xml配置文件（相对于Spring、SpringMVC来说）
    * 简化复杂的依赖管理（各个框架的各种版本）
    * 配合各种starter使用，基本上可以做到自动化配置（各个框架的各种配置）
    * 快速启动容器
* 缺点：
     * 从原来的xml配置方式转换到JAVA配置方式变化有点大，不太适应
     * Spring Boot比较适合做微服务，不适合做比较大型的项目。

# 官方文档
## Spring Framework
[官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/)
## Spring Data Jpa
[官方文档](https://docs.spring.io/spring-data/data-jpa/docs/current/reference/html/)
## Spring Boot
* [官方文档](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/)
* [文章](https://blog.csdn.net/fly_zhyu/article/details/76407830)