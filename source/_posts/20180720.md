---
title: 多线程
tags: 多线程
categories: Java
---


<!-- more -->
# 进程与线程
## 进程和线程
* 进程：CPU进行资源分配和调度的基本单位
* 线程：轻量级进程，程序执行的最小单元

## 并行和并发
* 并行：应用能够同时执行不同的任务
* 并发：应用能够交替执行不同的任务

## 创建线程的方式及实现
* 继承Thread，重写run（）方法
* 实现Runnable接口

## 线程间通信的方式
等待/通知机制：取票排队办业务
* 使用synchronized关键字实现同步
object.wait()//等待
object.notify()//通知
object.notifyAll()//通知所有
* 使用ReentrantLock和Condition实现同步
lock.lock();//获取锁
lock.unlock();//释放锁
condition.await()//等待
condition.signal()//通知
condition.signalAll()//通知所有

## CountDownLatch、CyclicBarrier
两者都是非常实用的多线程控制工具类
* CountDownLatch：“倒计时器”，它允许一个或多个线程一直等待，直到其他线程的操作
执行完后再执行。使用场景：实现最大的并行性、开始执行前等待n个线程完成各自任务、
死锁检测。
* CyclicBarrier：“循环屏障”，可循环使用的屏障。
* 两者的区别
	* CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 
	方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，
	可以重置计数器，并让线程们重新执行一次。
	* CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier
	阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。
	* CountDownLatch会阻塞主线程，CyclicBarrier不会阻塞主线程，只会阻塞子线程。

## Semaphore
计数信号量。Semaphore管理一系列许可证。每个acquire方法阻塞，直到有一个许可证可以
获得然后拿走一个许可证；每个release方法增加一个许可证，这可能会释放一个阻塞的
acquire方法。然而，其实并没有实际的许可证这个对象，Semaphore只是维持了一个可获得
许可证的数量。
Semaphore有两种模式，公平模式和非公平模式。公平模式就是调用acquire的顺序就是获取
许可证的顺序，遵循FIFO；而非公平模式是抢占式的，也就是有可能一个新的获取线程恰好
在一个许可证释放时得到了这个许可证，而前面还有等待的线程。

## Exchanger
一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，
在这个同步点两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据， 如果
第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange，当两个线程都
到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。

## ThreadLocal
ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地
改变自己的副本，而不会影响其它线程所对应的副本，容易造成OOM。

## 线程池
为了避免系统频繁的创建和销毁线程，我们可以将创建的线程进行复用。数据库中的数据库
连接池也是此意。
* 实现原理：
	1. 判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心
	线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，
	则进入下个流程。
	2. 线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个
	工作队列里。如果工作队列满了，则进入下个流程。
	3. 判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来
	执行任务。如果已经满了，则交给饱和策略来处理这个任务。
* 实现方式：
	* FixedThreadPool：固定线程数量的线程池
	* CachedThreadPool：可以根据实际情况调整线程数量的线程池
	* SingleThreadExecutor：只有一个线程的线程池
	* SingleThreadScheduledExecutor：和SingleThreadExecutor的区别是给定了时间执行
	某任务的功能，可以进行定时执行等
	* ScheduledThreadPool：在SingleThreadScheduledExecutor的基础上可以指定线程数量

## 线程的生命周期
* 新建（new）
* 运行（runnable）
* 阻塞（blocked）
* 限期等待（timed_waiting）
* 无限期等待（waiting）
* 结束（terminated）

# 锁机制
## 线程安全
当多个线程访问某一个类（对象或方法）时，这个类始终能表现出正确的行为，那么这个
类（对象或方法）就是线程安全的
线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，
其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据
污染。 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到
的数据是脏数据。

## 重入锁
当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的对象
锁时，如果该锁是重入锁,请求就会成功，否则阻塞。防止死锁。

## 死锁
* 产生的4个必要条件
	1. 互斥：某种资源一次只允许一个线程访问，即该资源一旦分配给某个线程，其他线
	程就不能再访问，直到该线程访问结束。
	2. 占有且等待：一个线程本身占有资源（一种或多种），同时还有资源未得到满足，
	正在等待其他进程释放该资源。
	3. 不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人
	的资源抢过来。
	4. 循环等待：存在一个线程链，使得每个线程都占有下一个线程所需的至少一种资源。
* 检查
通过jConsole（JDK自带的图形化界面工具）检查死锁

## volatile实现原理
* 禁止指令的重排序优化

* 提供内存可见性

## synchronized实现原理
关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在
同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和
排他性。

## synchronized 与 Lock 的区别
* synchronized是java关键字，Lock是java类
* synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁
* synchronized会自动释放锁，Lock需在finally中手工释放锁
* synchronized获取不到锁会一直等待，而Lock可以不用一直等待
* synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可中断、可公平可非公平
* Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题

## AQS
队列同步器，是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示
同步状态，通过内置的FIFO队列（先进先出）来完成资源获取线程的排队工作。

## CAS无锁、乐观锁、悲观锁
对于并发控制而言，锁是一种悲观的策略。它总是假设每一次的临界区操作会产生冲突，因此，
必须对每次操作都小心翼翼。如果有多个线程同时需要访问临界区资源，就宁可牺牲性能让
线程进行等待，所以说锁会阻塞线程执行。
而无锁是一种乐观的策略。它会假设对资源的访问是没有冲突的。既然没有冲突，自然不需
要等待，所以所有的线程都可以在不停顿的状态下持续执行。基于比较交换技术（CAS Compare
 And Swap）来鉴别线程冲突，一旦检测到冲突产生，就重试当前操作直到没有冲突为止。

## ABA问题
比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two
进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现
内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是
没有问题的。如果链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。

## 乐观锁的业务场景及实现方式
* 业务场景
读取频繁的场景
* 实现方式
原子类

## 并发类
* 阻塞队列
* 并发容器
* 线程池
* 锁
* 原子类型
* 并发工具

## 原子操作类
* 原子更新基本类型
* 原子更新数组类型
* 原子更新引用类型
* 原子更新属性类型

## 偏向锁、轻量级锁、重量级锁、自旋锁的概念
* 偏向锁
如果一个线程获得了锁，那么锁就进入了偏向模式。当这个线程再次请求锁时，无需再做任何
同步操作
* 轻量级锁
只是简单的将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有
对象锁
* 重量级锁
内置锁在Java中被抽象为监视器锁（monitor），同步方式的成本非常高，包括系统调用引起
的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”
* 自旋锁
通过自旋锁，可以减少线程阻塞造成的线程切换，竞争锁失败时先自旋并同时重新竞争锁，
如果自旋结束前还没有获取到锁，则阻塞自己
