---
title: 高效并发
tags: [Java,多线程]
categories: 后端开发
---

并发并不一定依赖多线程，但Java里谈论并发大多数都与线程脱不开关系。
线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源(内存地址，文件IO等)，又可以独立调度（线程是CPU调度的基本单位）。
<!-- more -->

# 应用场景
1. 多任务处理
计算机的运算速度与它的存储和通信子系统速度差距太大，大量的时间都花费在磁盘I/O，网络通信或数据库访问上。因此可以让计算机同时处理多项任务，从而充分利用计算器处理器的能力。
2. 服务端同时对多个客户端提供服务
例如WEB容器中就用到了多线程。

# Java内存模型
主内存与工作内存

# 并发的三大特性
1. 原子性

2. 可见性

3. 有序性

# 进程与线程
* 进程是资源分配的最小单位，线程是程序执行的最小单位。

# 并行与并发

# 线程调度
线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。
* 协同式线程调度：线程执行时间由线程本身来控制，线程把自己的工作执行完之后，要主动通知系统切换到另外一个线程上。最大好处是实现简单，且切换操作对线程自己是可知的，没啥线程同步问题。坏处是线程执行时间不可控制，如果一个线程有问题，可能一直阻塞在那里。
* 抢占式线程调度：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（Java中，Thread.yield()可以让出执行时间，但无法获取执行时间）。线程执行时间系统可控，也不会有一个线程导致整个进程阻塞。

# 线程池
* 工作原理
    1. 判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。
    2. 线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。
    3. 判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。
* 实现方式
    * 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
    * 创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。
    * 创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。
    * 创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。

# 线程优先级
希望系统能给某些线程多分配一些时间，给一些线程少分配一些时间，可以通过设置线程优先级来完成。Java语言一共10个级别的线程优先级（1级最低，10级最高），在两线程同时处于ready状态时，优先级越高的线程越容易被系统选择执行。但优先级并不是很靠谱，因为Java线程是通过映射到系统的原生线程上来实现的（平台上不同的优先级实际会变得相同，因为系统优先级比JAVA少或者优先级可能会被系统自行改变，如windows的“优先级推进器”），所以线程调度最终还是取决于操作系统。

# 线程状态（生命周期）
* 新建（NEW）
创建后尚未启动的线程
* 运行（RUNNABLE）
包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配时间。
* 无限期等待（WAITING）
不会被分配CPU执行时间，它们需要等待被其他线程显示地唤醒。以下方法会让线程进入此状态：
    * 没有设置Timeout参数的Object.wait()方法
    * 没有设置Timeout参数的Thread.join()方法
* 限期等待（TIMED_WAITING）
也不会被分配CPU执行时间，不过无须等待被其他线程显示地唤醒,在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入此状态：
    * Thread.sleep()方法
    * 设置了Timeout参数的Object.wait()方法
    * 设置了Timeout参数的Thread.join()方法
* 阻塞（BLOCKED）
线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或着唤醒动作的发生。
* 结束（TERMINATED）
线程执行结束。

# 线程安全
当多个线程访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。

# 线程安全级别
* 不可变
不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施。如String、Long、Double等。
* 绝对线程安全
不管运行时环境如何，调用者都不需要任何额外的同步措施。如Vector。
* 相对线程安全
我们通常意义上讲的线程安全。
* 线程兼容
对象本身并不是线程安全的，如ArrayList和HashMap等。
* 线程对立
无论调用端是否采取了同步措施，都无法在多线程中并发使用的代码。

# 线程安全的实现方法：
## 阻塞同步（悲观的并发策略）
互斥同步是常见的一种并发正确性保障手段。
同步是指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个（或者是一些，使用信号量的时候）线程使用。
互斥是实现同步的一种手段，主要实现方式有临界区、互斥量、信号量（Semaphore实现原理：Semaphore内部主要通过AQS（AbstractQueuedSynchronizer）实现线程的管理。Semaphore有两个构造函数，参数permits表示许可数，它最后传递给了AQS的state值。线程在运行时首先获取许可，如果成功，许可数就减1，线程运行，当线程运行结束就释放许可，许可数就加1。如果许可数为0，则获取失败，线程位于AQS的等待队列中，它会被其它释放许可的线程唤醒。在创建Semaphore对象的时候还可以指定它的公平性。一般常用非公平的信号量，非公平信号量是指在获取许可时先尝试获取许可，而不必关心是否已有需要获取许可的线程位于等待队列中，如果获取失败，才会入列。而公平的信号量在获取许可时首先要查看等待队列中是否已有线程，如果有则入列）。
互斥是因，同步是果；互斥是方法，同步是目的。
在Java中互斥同步手段有：synchronized关键字（会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。在执行monitorenter指令时，首先要尝试获取对象的锁，如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止）、ReentrantLock（增加了一些高级功能：等待可中断、可实现公平锁、以及锁可以绑定多个条件），两者性能差不多。

    
## 非阻塞同步（乐观的并发策略）
先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就采取其他的补偿措施（最常见的补偿措施就是不断的重试，直到成功为止）。
无法涵盖互斥同步的所有使用场景，例如ABA问题，传统的互斥同步可能比原子类更高效。
## 无同步方案
要保证线程安全，并不是一定就是要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段。
* 可重入代码
只要输入了相同的数据，就都能返回相同的结果的代码称为可重入代码。
* 线程本地存储（ThreadLocal）
为每个线程都创建一个变量副本, 每个线程都可以修改自己所拥有的变量副本, 而不会影响其他线程的副本。
常用于隔离多个线程之间的共享冲突（例如生产者-消费者模式的实例：经典Web交互模型中的“一个请求对应一个服务器线程”的处理方式）。
但ThreadLocal容易出现OOM（内存泄漏，由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用），最好是每次使用完ThreadLocal，都调用它的remove()方法，清除数据。
    
# JVM线程优化
* 锁优化
* 锁消除
* 锁粗化
* 轻量级锁
* 偏向锁

# Java并发工具
## 并发容器
## 同步容器
## 阻塞队列
## Synchronizer
* CountDownLatch
一个线程(或者多个)，等待另外N个线程完成某个事情之后才能执行
* CyclicBarrier
N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待
* Exchanger
用于成对出现的线程之间交换数据

# 经典并发问题
* 生产者-消费者问题
* 哲学家就餐问题
* 读者-作者问题
* 熟睡的理发师问题
* 三个烟鬼的问题