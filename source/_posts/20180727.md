---
title: 高效并发
tags: [Java,多线程]
categories: 后端开发
---

并发并不一定依赖多线程，但Java里谈论并发大多数都与线程脱不开关系。
线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源(内存地址，文件IO等)，又可以独立调度（线程是CPU调度的基本单位）。
<!-- more -->

# 应用场景
1. 多任务处理
计算机的运算速度与它的存储和通信子系统速度差距太大，大量的时间都花费在磁盘I/O，网络通信或数据库访问上。因此可以让计算机同时处理多项任务，从而充分利用计算器处理器的能力。
2. 服务端同时对多个客户端提供服务
例如WEB容器中就用到了多线程。

# 基本概念、
## Java内存模型
主内存与工作内存

## 并发的三大特性
1. 原子性

2. 可见性

3. 有序性

## 进程与线程的区别
* 进程是资源分配的最小单位，线程是程序执行的最小单位。
* 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
* 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点
* 多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间

## 线程调度
线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。
* 协同式线程调度：线程执行时间由线程本身来控制，线程把自己的工作执行完之后，要主动通知系统切换到另外一个线程上。最大好处是实现简单，且切换操作对线程自己是可知的，没啥线程同步问题。坏处是线程执行时间不可控制，如果一个线程有问题，可能一直阻塞在那里。
* 抢占式线程调度：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（Java中，Thread.yield()可以让出执行时间，但无法获取执行时间）。线程执行时间系统可控，也不会有一个线程导致整个进程阻塞。

## 线程池
ThreadPoolExecutor
1. 判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。
2. 线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。
3. 判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。

## 线程优先级
希望系统能给某些线程多分配一些时间，给一些线程少分配一些时间，可以通过设置线程优先级来完成。Java语言一共10个级别的线程优先级（1级最低，10级最高），在两线程同时处于ready状态时，优先级越高的线程越容易被系统选择执行。但优先级并不是很靠谱，因为Java线程是通过映射到系统的原生线程上来实现的（平台上不同的优先级实际会变得相同，因为系统优先级比JAVA少或者优先级可能会被系统自行改变，如windows的“优先级推进器”），所以线程调度最终还是取决于操作系统。

## 线程状态（生命周期）
* 新建（NEW）
创建后尚未启动的线程
* 运行（RUNNABLE）
包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配时间。
* 无限期等待（WAITING）
不会被分配CPU执行时间，它们需要等待被其他线程显示地唤醒。以下方法会让线程进入此状态：
    * 没有设置Timeout参数的Object.wait()方法
    * 没有设置Timeout参数的Thread.join()方法
* 限期等待（TIMED_WAITING）
也不会被分配CPU执行时间，不过无须等待被其他线程显示地唤醒,在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入此状态：
    * Thread.sleep()方法
    * 设置了Timeout参数的Object.wait()方法
    * 设置了Timeout参数的Thread.join()方法
* 阻塞（BLOCKED）
线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或着唤醒动作的发生。
* 结束（TERMINATED）
线程执行结束。

## 线程安全
当多个线程访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。

## 线程安全级别
* 不可变
不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施。如String、Long、Double等。
* 绝对线程安全
不管运行时环境如何，调用者都不需要任何额外的同步措施。如Vector。
* 相对线程安全
我们通常意义上讲的线程安全。
* 线程兼容
对象本身并不是线程安全的，如ArrayList和HashMap等。
* 线程对立
无论调用端是否采取了同步措施，都无法在多线程中并发使用的代码。

## 线程安全的实现方法：
* 阻塞同步（悲观的并发策略）
互斥同步是常见的一种并发正确性保障手段。
同步是指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个（或者是一些，使用信号量的时候）线程使用。
互斥是实现同步的一种手段，主要实现方式有临界区、互斥量、信号量。
互斥是因，同步是果；互斥是方法，同步是目的。
在Java中互斥同步手段有：synchronized关键字、Lock类，两者性能差不多。
* 非阻塞同步（乐观的并发策略）
先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就采取其他的补偿措施（最常见的补偿措施就是不断的重试，直到成功为止）。
无法涵盖互斥同步的所有使用场景，例如ABA问题，传统的互斥同步可能比原子类更高效。
* 无同步方案
    * 可重入代码
    * 线程本地存储（ThreadLocal）
    
## JVM线程优化
* 锁优化
* 锁消除
* 锁粗化
* 轻量级锁
* 偏向锁

## JavaAPI线程优化
* 并发容器
* 同步容器

## 经典并发问题
* 生产者-消费者问题
* 哲学家就餐问题
* 读者-作者问题
* 熟睡的理发师问题
* 三个烟鬼的问题